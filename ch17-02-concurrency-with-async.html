<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concurrency With Async - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">
        <link rel="stylesheet" href="theme/semantic-notes.css">
        <link rel="stylesheet" href="theme/listing.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">The Rust Programming Language</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Programming a Guessing Game</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Common Programming Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variables and Mutability</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Comments</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Control Flow</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Understanding Ownership</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> What is Ownership?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> References and Borrowing</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> The Slice Type</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Using Structs to Structure Related Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Defining and Instantiating Structs</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> An Example Program Using Structs</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Method Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Enums and Pattern Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Defining an Enum</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> The match Control Flow Construct</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Managing Growing Projects with Packages, Crates, and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Packages and Crates</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Common Collections</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Storing Lists of Values with Vectors</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Error Handling</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Unrecoverable Errors with panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Recoverable Errors with Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> To panic! or Not to panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generic Types, Traits, and Lifetimes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generic Data Types</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Traits: Defining Shared Behavior</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Writing Automated Tests</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> How to Write Tests</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Controlling How Tests Are Run</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Test Organization</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> An I/O Project: Building a Command Line Program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Accepting Command Line Arguments</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Reading a File</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Working with Environment Variables</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Functional Language Features: Iterators and Closures</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Closures: Anonymous Functions that Capture Their Environment</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Processing a Series of Items with Iterators</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Improving Our I/O Project</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> More about Cargo and Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Customizing Builds with Release Profiles</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Publishing a Crate to Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo Workspaces</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Smart Pointers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Using Box&lt;T&gt; to Point to Data on the Heap</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc&lt;T&gt;, the Reference Counted Smart Pointer</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell&lt;T&gt; and the Interior Mutability Pattern</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Fearless Concurrency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Shared-State Concurrency</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-async-await.html"><strong aria-hidden="true">17.</strong> Async and Await</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-futures-and-syntax.html"><strong aria-hidden="true">17.1.</strong> Futures and the Async Syntax</a></li><li class="chapter-item expanded "><a href="ch17-02-concurrency-with-async.html" class="active"><strong aria-hidden="true">17.2.</strong> Concurrency With Async</a></li><li class="chapter-item expanded "><a href="ch17-03-more-futures.html"><strong aria-hidden="true">17.3.</strong> Working With More Futures</a></li><li class="chapter-item expanded "><a href="ch17-04-more-ways-of-combining-futures.html"><strong aria-hidden="true">17.4.</strong> More Ways of Combining Futures</a></li><li class="chapter-item expanded "><a href="ch17-05-streams.html"><strong aria-hidden="true">17.5.</strong> Streams</a></li><li class="chapter-item expanded "><a href="ch17-06-futures-tasks-threads.html"><strong aria-hidden="true">17.6.</strong> Futures, Tasks, and Threads</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-oop.html"><strong aria-hidden="true">18.</strong> Object Oriented Programming Features of Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-what-is-oo.html"><strong aria-hidden="true">18.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class="chapter-item expanded "><a href="ch18-02-trait-objects.html"><strong aria-hidden="true">18.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class="chapter-item expanded "><a href="ch18-03-oo-design-patterns.html"><strong aria-hidden="true">18.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-patterns.html"><strong aria-hidden="true">19.</strong> Patterns and Matching</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-all-the-places-for-patterns.html"><strong aria-hidden="true">19.1.</strong> All the Places Patterns Can Be Used</a></li><li class="chapter-item expanded "><a href="ch19-02-refutability.html"><strong aria-hidden="true">19.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class="chapter-item expanded "><a href="ch19-03-pattern-syntax.html"><strong aria-hidden="true">19.3.</strong> Pattern Syntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-advanced-features.html"><strong aria-hidden="true">20.</strong> Advanced Features</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-unsafe-rust.html"><strong aria-hidden="true">20.1.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch20-03-advanced-traits.html"><strong aria-hidden="true">20.2.</strong> Advanced Traits</a></li><li class="chapter-item expanded "><a href="ch20-04-advanced-types.html"><strong aria-hidden="true">20.3.</strong> Advanced Types</a></li><li class="chapter-item expanded "><a href="ch20-05-advanced-functions-and-closures.html"><strong aria-hidden="true">20.4.</strong> Advanced Functions and Closures</a></li><li class="chapter-item expanded "><a href="ch20-06-macros.html"><strong aria-hidden="true">20.5.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><a href="ch21-00-final-project-a-web-server.html"><strong aria-hidden="true">21.</strong> Final Project: Building a Multithreaded Web Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch21-01-single-threaded.html"><strong aria-hidden="true">21.1.</strong> Building a Single-Threaded Web Server</a></li><li class="chapter-item expanded "><a href="ch21-02-multithreaded.html"><strong aria-hidden="true">21.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class="chapter-item expanded "><a href="ch21-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">21.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">22.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">22.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">22.2.</strong> B - Operators and Symbols</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">22.3.</strong> C - Derivable Traits</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">22.4.</strong> D - Useful Development Tools</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">22.5.</strong> E - Editions</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">22.6.</strong> F - Translations of the Book</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">22.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="concurrency-with-async"><a class="header" href="#concurrency-with-async">Concurrency With Async</a></h2>
<p>In this section, we will apply async to some of the same concurrency challenges
we tackled with threads in chapter 16. Since we already talked about a lot of
the key ideas there, in this section we will focus on what is different between
threads and futures.</p>
<p>In many cases, the APIs for working with concurrency using async are very
similar to those for using threads. In other cases, they end up being shaped
fairly differently. Even when the APIs look similar, they often have different
behavior and they nearly always have different performance characteristics.</p>
<h3 id="counting"><a class="header" href="#counting">Counting</a></h3>
<p>The first task we tackled in Chapter 16 was counting up on two separate threads.
Let’s do the same using async. The <code>trpl</code> crate supplies a <code>spawn_task</code> function
which looks very similar to the <code>thread::spawn</code> API, and a <code>sleep</code> function
which is an async version of the <code>thread::sleep</code> API. We can use these together
to implement the same counting example as with threads.</p>
<p>Listing 17-4 shows our starting point. We set up our <code>main</code> function with <code>trpl::block_on</code>, so that our top-level function can be async.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    trpl::block_on(async {
        // our implementation will go here
    });
<span class="boring">}</span></code></pre></pre>
<section class="note" aria-role="note">
<p>Note: From this point forward in the chapter, every example will include this
exact same wrapping code with <code>trpl::block_on</code> in <code>main</code>, so we will often
skip it just like we do with <code>main</code>. Don’t forget to include it in your
code!</p>
</section>
<p>Then we can write two loops within that block, each with a <code>trpl::sleep</code> call in
them. Similar to the threading example, we put one loop in the body of a
<code>trpl::spawn_task</code>, the same way we did with <code>thread::spawn</code>, and the other in a
top-level <code>for</code> loop. Notice that we also need to add a <code>.await</code> after the
<code>sleep</code> calls.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(1)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(1)).await;
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-5: Using <code>spawn_task</code> to count with two</figcaption>
</figure>
<p>This does something very similar to what the thread-based implementation did, as
we can see from the output when we run it. (As with the threading example, you
may see a different order in your own terminal output when you run this.)</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
</code></pre>
<p>This stops as soon as the for loop in the body of the main async block finishes,
because the task spawned by <code>spawn_task</code> is shut down when the main function
ends—just like threads are. Thus, if you want to run all the way to the
completion of the task, you will need to use a join handle to wait for the first
task to complete. With threads, we used the <code>join</code> method to “block” until the
thread was done running. Here, we can use <code>await</code> to do the same thing, and
since the handle’s output is actually a <code>Result</code>, we will also unwrap it.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let handle = trpl::spawn_task(async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(1)).await;
            }
        });

        for i in 1..5 {
            println!("hi number {i} from the second task!");
            trpl::sleep(Duration::from_millis(1)).await;
        }

        handle.await.unwrap();
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-6: Using <code>.await</code> with a join handle to run a task to completion</figcaption>
</figure>
<p>Now the output again looks like what we saw in the threading example. (Again,
the exact output may look different for you.)</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the second task!
hi number 1 from the first task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>So far, it looks like async and threads basically give us the same basic
behavior. However, there are a few important differences already. One was using
<code>.await</code> instead of calling <code>join</code> on the join handle. Another is that we needed
to await both <code>sleep</code> calls. Most importantly, though, we did not need to spawn
another operating system thread to do this. We were able to get concurrency for
just the cost of a task, which has much faster startup time and uses much less
memory than an OS thread.</p>
<p>What is more, we actually do not need the <code>spawn_task</code> call at all to get
concurrency here. Remember that each async block compiles to an anonymous
future. That means we can put each of these two loops in an async block and then
ask the runtime to run them both to completion using <code>trpl::join</code>:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let fut1 = async {
            for i in 1..10 {
                println!("hi number {i} from the first task!");
                trpl::sleep(Duration::from_millis(1)).await;
            }
        };

        let fut2 = async {
            for i in 1..5 {
                println!("hi number {i} from the second task!");
                trpl::sleep(Duration::from_millis(1)).await;
            }
        };

        trpl::join(fut1, fut2).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-7: Using <code>trpl::join</code> to await two anonymous futures</figcaption>
</figure>
<p>When we run this, we see both futures run to completion:</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">hi number 1 from the first task!
hi number 1 from the second task!
hi number 2 from the first task!
hi number 2 from the second task!
hi number 3 from the first task!
hi number 3 from the second task!
hi number 4 from the first task!
hi number 4 from the second task!
hi number 5 from the first task!
hi number 6 from the first task!
hi number 7 from the first task!
hi number 8 from the first task!
hi number 9 from the first task!
</code></pre>
<p>Here, you will see the exact same order every time, which is very different from
what we saw with threads. That is because the <code>trpl::join</code> function is <em>fair</em>,
meaning it checks both futures equally, rather than letting one race ahead. With
threads, the operating system decides which thread to check, and that is
ultimately out of our control. With an async runtime, the runtime itself decides
which future to check, so it has the final say. In practice, the details get
complicated because an async runtime might use operating system threads under
the hood as part of how it manages concurrency, but a runtime can still choose
to guarantee fairness even so. However, runtimes do not have to guarantee
fairness for any given operation, and even within a given runtime, different
APIs sometimes exist to let you choose whether fairness is something you care
about as a caller.</p>
<p>Try some of these different variations on awaiting the futures and see what they
do:</p>
<ul>
<li>Remove the async block from around either or both of the loops.</li>
<li>Await each async block immediately after defining it.</li>
<li>Wrap only the first loop in an async block, and await the resulting future
after the body of second loop.</li>
</ul>
<p>For an extra challenge, see if you can figure out what the output will be in
each case <em>before</em> running the code!</p>
<h3 id="message-passing"><a class="header" href="#message-passing">Message Passing</a></h3>
<p>Sharing data between futures will look familiar. We can again use async versions
of Rust’s types for message-passing. Instead of <code>std::sync:mpsc::channel</code>, we
will use a <code>tprl::channel</code>, for example.</p>
<p>The synchronous <code>Receiver::recv()</code> method in <code>std::mpsc::channel</code> blocks until
it receives a message. The <code>trpl::Receiver::recv()</code> method, by contrast, is an
<code>async</code> function. Instead of blocking, it waits until a message is received or
the send side of the channel closes. One other difference with this particular
<code>recv()</code> implementation is that it returns an <code>Option</code> of the type sent over the
channel instead of a <code>Result</code>.</p>
<p>We can start by introducing an async version of the multiple-producer,
single-consumer channel channel API we used with threads back in Chapter 16. The
API is just a little different here in Listing 17-8: we have a mutable receiver
<code>rx</code>. Otherwise, this looks pretty much the same as the thread-based approach.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();
<span class="boring">
</span><span class="boring">        let val = String::from("hi");
</span><span class="boring">        tx.send(val).unwrap();
</span><span class="boring">
</span><span class="boring">        let received = rx.recv().await.unwrap();
</span><span class="boring">        println!("Got: {received}");
</span><span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-8: Creating an async channel and assigning the two halves to <code>tx</code> and <code>rx</code></figcaption>
</figure>
<p>Now we can send messages from the sender to the receiver. Again, the API is just
a little different from the threaded version in Chapter 16, where we needed to
spawn a separate thread to allow the message passing to happen asynchronously.
In the version in Listing 17-9, we opt into async behavior on the receiver side
by using <code>.await</code> on the <code>rx.recv()</code> call.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let val = String::from("hi");
        tx.send(val).unwrap();

        let received = rx.recv().await.unwrap();
        println!("Got: {received}");
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-9: Sending <code>"hi"</code> from <code>tx</code> and receiving it in <code>rx</code></figcaption>
</figure>
<p>The <code>send</code> call does not block, since the channel we are sending it into is
unbounded. That was true with our threading example back in Chapter 16, too,
though. However, there is a big difference with the <code>rx.recv()</code> calls. The one
back in Chapter 16 blocked the thread it ran on—in that case, the main thread.
This one does not block at all! Instead, once the program hits the <code>.await</code> on
the <code>rx.recv()</code> call, it hands control back to the runtime, which can go on
scheduling other operations until a message arrives. It might be hard to see
that from this code, though, since the message will arrive right away!</p>
<section class="note" aria-role="note">
<p>Note: Since this is all wrapped in a <code>trpl::block_on</code>, this would effectively
block anything happening outside that. That is the whole point of <code>block_on</code>,
in fact: to allow you to <em>choose</em> where to block on some set of async code to
transition between sync and async code. However, <em>within</em> this block, the
<code>.await</code> does not block further operations—as we will see!</p>
</section>
<p>Let’s go ahead and send a whole series of messages, and sleep in between them,
as shown in Listing 17-10:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>
        // snip...

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_secs(1)).await;
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-10: Sending multiple messages over the async channel and sleeping with an <code>.await</code> between each message</figcaption>
</figure>
<p>This handles sending the messages, but so far we don’t do anything with them,
and the code just silently runs forever. We need to actually <em>receive</em> the
messages. In this case, we could do that manually, because we know how many
messages are coming in. In the real world, though, we will generally be waiting
on some <em>unknown</em> number of messages. In that case, we need to keep waiting
until we determine that there are no more messages.</p>
<p>That sounds like a good job for a loop! In synchronous code, we might use a
<code>for</code> loop to process a sequence of items, regardless of how many items are in
the loop. However, Rust does not yet have a way to write a <code>for</code> loop over an
<em>asynchronous</em> series of items. Instead, we need to use a new kind of loop we
haven’t seen before, the <code>while let</code> conditional loop. A <code>while let</code> loop is the
loop version of the <code>if let</code> construct we saw back in Chapter 6. It continues as
long as the condition it relies on is true. Listing 17-11 shows how we can use
this with <code>rx.recv</code> to print all the messages send by the <code>tx</code> transmitter.</p>
<!-- TODO: update text in ch. 19 to account for our having introduced this. -->
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let vals = vec![
</span><span class="boring">            String::from("hi"),
</span><span class="boring">            String::from("from"),
</span><span class="boring">            String::from("the"),
</span><span class="boring">            String::from("future"),
</span><span class="boring">        ];
</span><span class="boring">
</span><span class="boring">        for val in vals {
</span><span class="boring">            tx.send(val).unwrap();
</span><span class="boring">            trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">        }
</span><span class="boring">
</span>        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-11: Using a <code>while let</code> loop with <code>.await</code> to receive messages asynchronously</figcaption>
</figure>
<p>The <code>rx.recv()</code> call produces a <code>Future</code>. The <code>Output</code> of the future is an
<code>Option</code> of the message type. While waiting on messages, it will respond with
<code>Poll::Pending</code>, so the runtime will pause it until it is time to check it
again. Once a message arrives, it will respond with
<code>Poll::Ready(Some(message))</code>. When the channel closes, it will instead respond
with <code>Poll::Ready(None)</code>, which we can use to know that it is done. The <code>while let</code> pulls all of this together. If the result of calling <code>rx.recv().await</code> is
<code>Some(message)</code>, we get access to the message and we can use it in the loop
body, just like we could with <code>if let</code>. If the result is <code>None</code>, the loop ends.
Every time the loop completes, it hits the await point again, so the runtime
pauses it again until another message arrives.</p>
<p>With the <code>while let</code> loop in place, the code now successfully sends and receives
the messages. Unfortunately, there are still a couple problems. For one thing,
the messages do not arrive at one-second intervals, we see them arrive all at
once, four seconds after we start the program. For another, this program also
never stops! You will need to shut it down using <span
class="keystroke">ctrl-c</span>.</p>
<p>Let’s start by understanding why the messages all come in at once after the full
delay, rather than coming in with delays in between each one. This highlights an
important point about the way that async works in Rust. Within any given async
block, the await points are sequential: each one happens one after another. That
is, after all, one of the big motivations for using this syntax instead of
callbacks, event handlers, or chains of methods: the flow through the program is
much easier to follow, because having the order that <code>.await</code> keywords appear in
the <em>code</em> is also the order they happen when running the <em>program</em>.</p>
<p>With that in mind, we can see why this code behaves the way it does by looking
at the whole thing all together, in Listing 17-12.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust">use std::time::Duration;

fn main() {
    trpl::block_on(async {
        let (tx, mut rx) = trpl::channel();

        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("future"),
        ];

        for val in vals {
            tx.send(val).unwrap();
            trpl::sleep(Duration::from_secs(1)).await;
        }

        while let Some(value) = rx.recv().await {
            println!("received '{value}'");
        }
    });
}</code></pre></pre>
<figcaption>Listing 17-12: An async block with multiple <code>.await</code> points in it</figcaption>
</figure>
<p>There is just one async block here, so everything here will proceed linearly.
Every one of the <code>.await</code> points for the <code>trpl::sleep</code> calls appears before the
<code>.await</code> points on the <code>rx.recv()</code>, so all the <code>tx.send</code> calls happen,
interspersed with all of the <code>trpl::sleep</code> calls. Only then does the <code>while let</code>
loop get to go through all of the <code>.await</code> points on the <code>recv</code> calls.</p>
<p>To get the behavior we actually want, where the delay happens in between
receiving each message, rather than before receiving any message, we need to
give put the <code>tx</code> and <code>rx</code> operations in their own async blocks, so the runtime
can execute each of them separately. We also need to tell the runtime to
actually run them using <code>trpl::join</code>, just like we did for the counting example
above. Listing 17-13 shows how that looks.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span>        let tx_fut = async {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-13: Separating <code>send</code> and <code>recv</code> into their own <code>async</code> blocks and awaiting the futures for those blocks</figcaption>
</figure>
<p>With these changes made, the messages get printed at one-second intervals,
rather than all in a rush after four seconds.</p>
<p>The program still never stops running, though. That’s because of the combination
of the <code>while let</code> loop and the <code>trpl::join</code> call. Let’s consider the way this
loop works:</p>
<ul>
<li>The <code>trpl::join</code> future only completes once <em>both</em> futures passed to it
have completed.</li>
<li>The <code>tx</code> future completes once it finishes sleeping after sending the last
message in <code>vals</code>.</li>
<li>The <code>rx</code> future will not complete until the <code>while let</code> loop ends.</li>
<li>The <code>while let</code> loop will not end until <code>rx.recv().await</code> produces <code>None</code>.</li>
<li>The <code>rx.recv().await</code> will only return <code>None</code> once the other end of the
channel is closed.</li>
<li>The channel will only close if we call <code>rx.close()</code> or when the sender side,
<code>tx</code>, is dropped.</li>
<li>We do not call <code>rx.close()</code> anywhere, and <code>tx</code> will not be dropped until the
async block ends.</li>
<li>The block cannot end because it is blocked on <code>trpl::join</code> completing,
which takes us back to the top of this list!</li>
</ul>
<p>We need to make sure the channel gets closed so that <code>trpl::join</code> will complete.
We could manually close <code>rx</code> somewhere by calling <code>rx.close()</code>, but that does
not make much sense in this case. The idea is that <code>rx</code> should keep listening
until <code>tx</code> is done sending. Stopping after handling some arbitrary number of
messages would make the program shut down, but it would mean we could miss
messages if the sending side changed. Given that we cannot use <code>rx.close()</code>, we
need to make sure that <code>tx</code> gets dropped <em>before</em> the end of the function.</p>
<p>Right now, the async block only borrows <code>tx</code>. We can confirm this by adding
another async block which uses <code>tx</code>, and using <code>trpl::join3</code> to wait for all
three futures to complete:</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span><span class="boring">        let (tx, mut rx) = trpl::channel();
</span><span class="boring">
</span><span class="boring">        let tx_fut = async {
</span><span class="boring">            let vals = vec![
</span><span class="boring">                String::from("hi"),
</span><span class="boring">                String::from("from"),
</span><span class="boring">                String::from("the"),
</span><span class="boring">                String::from("future"),
</span><span class="boring">            ];
</span><span class="boring">
</span><span class="boring">            for val in vals {
</span><span class="boring">                tx.send(val).unwrap();
</span><span class="boring">                trpl::sleep(Duration::from_secs(1)).await;
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        let rx_fut = async {
</span><span class="boring">            while let Some(received) = rx.recv().await {
</span><span class="boring">                println!("Got: {received}");
</span><span class="boring">            }
</span><span class="boring">        };
</span><span class="boring">
</span>        let tx_fut2 = async {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        trpl::join3(tx_fut, tx_fut2, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-14: Adding another async block which borrows <code>tx</code>, to see that we can borrow it repeatedly</figcaption>
</figure>
<p>Now both blocks borrow <code>tx</code>, so they are both able to use it to send messages,
which <code>rx</code> can then receive. When we run that code, we see the extra output from
the new <code>async</code> block, and the message it sends being received by the
<code>rx.recv()</code>.</p>
<!-- Not extracting output because changes to this output aren't significant;
the changes are likely to be due to the threads running differently rather than
changes in the compiler -->
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: the
Got: for
Got: future
Got: you
</code></pre>
<p>As before, we also see that the program does not shut down on its own and
requires a <span class="keystroke">ctrl-c</span>. This little exploration helps
us understand why: it is ultimately about <em>ownership</em>. We need to move <code>tx</code> into
the async block so that once that block ends, <code>tx</code> will be dropped.</p>
<p>Since we have seen how <code>async</code> blocks borrow the items they reference from their
outer scope, we can go ahead and remove the extra block we just added for now,
and switch back from <code>join3</code> to <code>join</code>.</p>
<p>The last step here is to figure out how to get ownership of the data instead of
just borrowing it. In Chapter 13, we learned how to use the <code>move</code> keyword with
closures, and in Chapter 16, we saw that we often need to use closures marked
with <code>move</code> when working with threads. As we have discovered, the same dynamics
apply to async blocks! Hopefully this will make sense if you remember that any
time you write a future, a runtime is ultimately responsible for executing it.
That means that an async block might outlive the function where you write it,
the same way a closure can. When a future takes ownership of the data it
references this way, it needs to move that data into the future—so the <code>move</code>
keyword works with async blocks just like it does with closures.</p>
<p>Thus, we can change the first async block from an <code>async</code> block to an <code>async move</code> block, like this:</p>
<p>The result is Listing 17-15, and when we run <em>this</em> version of the code, it
shuts down gracefully after the last message is sent.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                eprintln!("received '{value}'");
            }
        };

        trpl::join(tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-15: A working example of sending and receiving messages between futures which correctly shuts down when complete</figcaption>
</figure>
<p>This async channel is also a multiple-producer channel, so we can call <code>clone</code>
on <code>tx</code> if we want to send messages from multiple futures. For example, we can
make the code from Listing 17-16 work by cloning the <code>tx</code> before moving it
into the first async block, moving the original <code>tx</code> into the second async
block, and switching back to <code>join3</code>.</p>
<figure class="listing">
<span class="file-name">Filename: src/main.rs</span>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    trpl::block_on(async {
</span>        let (tx, mut rx) = trpl::channel();

        let tx1 = tx.clone();
        let tx1_fut = async move {
            let vals = vec![
                String::from("hi"),
                String::from("from"),
                String::from("the"),
                String::from("future"),
            ];

            for val in vals {
                tx1.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        let rx_fut = async {
            while let Some(value) = rx.recv().await {
                println!("received '{value}'");
            }
        };

        let tx_fut = async move {
            let vals = vec![
                String::from("more"),
                String::from("messages"),
                String::from("for"),
                String::from("you"),
            ];

            for val in vals {
                tx.send(val).unwrap();
                trpl::sleep(Duration::from_secs(1)).await;
            }
        };

        trpl::join3(tx1_fut, tx_fut, rx_fut).await;
<span class="boring">    });
</span><span class="boring">}</span></code></pre></pre>
<figcaption>Listing 17-16: Using multiple producers with async blocks</figcaption>
</figure>
<p><em>Both</em> of these blocks need to be <code>async move</code> blocks, or else we will end up
back in the same infinite loop we started out in. With that done, though, we get
all the messages we expected, with little delays between them. Notice that since
each of the sending futures do a one-second delay after sending, the messages
come in right after each other at one-second intervals. The delays are
concurrent, not sequential, just as we would expect.</p>
<p>This is a good start, but it limits us to just a handful of futures: two with
<code>join</code>, or three with <code>join3</code>. Let’s see how we might work with more futures.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch17-01-futures-and-syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch17-03-more-futures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch17-01-futures-and-syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch17-03-more-futures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
